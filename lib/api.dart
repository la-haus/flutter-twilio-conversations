// Autogenerated from Pigeon (v1.0.19), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name
// @dart = 2.12
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/foundation.dart' show WriteBuffer, ReadBuffer;
import 'package:flutter/services.dart';

class ConversationClientData {
  ConversationClientData({
    this.myIdentity,
    this.connectionState,
    this.isReachabilityEnabled,
  });

  String? myIdentity;
  String? connectionState;
  bool? isReachabilityEnabled;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['myIdentity'] = myIdentity;
    pigeonMap['connectionState'] = connectionState;
    pigeonMap['isReachabilityEnabled'] = isReachabilityEnabled;
    return pigeonMap;
  }

  static ConversationClientData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ConversationClientData(
      myIdentity: pigeonMap['myIdentity'] as String?,
      connectionState: pigeonMap['connectionState'] as String?,
      isReachabilityEnabled: pigeonMap['isReachabilityEnabled'] as bool?,
    );
  }
}

class PropertiesData {
  PropertiesData({
    this.region,
  });

  String? region;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['region'] = region;
    return pigeonMap;
  }

  static PropertiesData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PropertiesData(
      region: pigeonMap['region'] as String?,
    );
  }
}

class ConversationData {
  ConversationData({
    this.sid,
    this.attributes,
    this.uniqueName,
    this.friendlyName,
    this.status,
    this.synchronizationStatus,
    this.dateCreated,
    this.createdBy,
    this.dateUpdated,
    this.lastMessageDate,
    this.lastReadMessageIndex,
    this.lastMessageIndex,
  });

  String? sid;
  AttributesData? attributes;
  String? uniqueName;
  String? friendlyName;
  String? status;
  String? synchronizationStatus;
  String? dateCreated;
  String? createdBy;
  String? dateUpdated;
  String? lastMessageDate;
  int? lastReadMessageIndex;
  int? lastMessageIndex;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['uniqueName'] = uniqueName;
    pigeonMap['friendlyName'] = friendlyName;
    pigeonMap['status'] = status;
    pigeonMap['synchronizationStatus'] = synchronizationStatus;
    pigeonMap['dateCreated'] = dateCreated;
    pigeonMap['createdBy'] = createdBy;
    pigeonMap['dateUpdated'] = dateUpdated;
    pigeonMap['lastMessageDate'] = lastMessageDate;
    pigeonMap['lastReadMessageIndex'] = lastReadMessageIndex;
    pigeonMap['lastMessageIndex'] = lastMessageIndex;
    return pigeonMap;
  }

  static ConversationData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ConversationData(
      sid: pigeonMap['sid'] as String?,
      attributes: pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null,
      uniqueName: pigeonMap['uniqueName'] as String?,
      friendlyName: pigeonMap['friendlyName'] as String?,
      status: pigeonMap['status'] as String?,
      synchronizationStatus: pigeonMap['synchronizationStatus'] as String?,
      dateCreated: pigeonMap['dateCreated'] as String?,
      createdBy: pigeonMap['createdBy'] as String?,
      dateUpdated: pigeonMap['dateUpdated'] as String?,
      lastMessageDate: pigeonMap['lastMessageDate'] as String?,
      lastReadMessageIndex: pigeonMap['lastReadMessageIndex'] as int?,
      lastMessageIndex: pigeonMap['lastMessageIndex'] as int?,
    );
  }
}

class AttributesData {
  AttributesData({
    this.type,
    this.data,
  });

  String? type;
  String? data;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['type'] = type;
    pigeonMap['data'] = data;
    return pigeonMap;
  }

  static AttributesData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return AttributesData(
      type: pigeonMap['type'] as String?,
      data: pigeonMap['data'] as String?,
    );
  }
}

class TokenData {
  TokenData({
    this.token,
  });

  String? token;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['token'] = token;
    return pigeonMap;
  }

  static TokenData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return TokenData(
      token: pigeonMap['token'] as String?,
    );
  }
}

class MessageMediaData {
  MessageMediaData({
    this.sid,
    this.fileName,
    this.type,
    this.size,
    this.conversationSid,
    this.messageSid,
    this.messageIndex,
  });

  String? sid;
  String? fileName;
  String? type;
  int? size;
  String? conversationSid;
  String? messageSid;
  int? messageIndex;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['fileName'] = fileName;
    pigeonMap['type'] = type;
    pigeonMap['size'] = size;
    pigeonMap['conversationSid'] = conversationSid;
    pigeonMap['messageSid'] = messageSid;
    pigeonMap['messageIndex'] = messageIndex;
    return pigeonMap;
  }

  static MessageMediaData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageMediaData(
      sid: pigeonMap['sid'] as String?,
      fileName: pigeonMap['fileName'] as String?,
      type: pigeonMap['type'] as String?,
      size: pigeonMap['size'] as int?,
      conversationSid: pigeonMap['conversationSid'] as String?,
      messageSid: pigeonMap['messageSid'] as String?,
      messageIndex: pigeonMap['messageIndex'] as int?,
    );
  }
}

class MessageData {
  MessageData({
    this.sid,
    this.messageIndex,
    this.author,
    this.subject,
    this.messageBody,
    this.type,
    this.hasMedia,
    this.media,
    this.conversationSid,
    this.participantSid,
    this.dateCreated,
    this.dateUpdated,
    this.lastUpdatedBy,
    this.attributes,
  });

  String? sid;
  int? messageIndex;
  String? author;
  String? subject;
  String? messageBody;
  String? type;
  bool? hasMedia;
  MessageMediaData? media;
  String? conversationSid;
  String? participantSid;
  String? dateCreated;
  String? dateUpdated;
  String? lastUpdatedBy;
  AttributesData? attributes;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['messageIndex'] = messageIndex;
    pigeonMap['author'] = author;
    pigeonMap['subject'] = subject;
    pigeonMap['messageBody'] = messageBody;
    pigeonMap['type'] = type;
    pigeonMap['hasMedia'] = hasMedia;
    pigeonMap['media'] = media == null ? null : media!.encode();
    pigeonMap['conversationSid'] = conversationSid;
    pigeonMap['participantSid'] = participantSid;
    pigeonMap['dateCreated'] = dateCreated;
    pigeonMap['dateUpdated'] = dateUpdated;
    pigeonMap['lastUpdatedBy'] = lastUpdatedBy;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    return pigeonMap;
  }

  static MessageData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageData(
      sid: pigeonMap['sid'] as String?,
      messageIndex: pigeonMap['messageIndex'] as int?,
      author: pigeonMap['author'] as String?,
      subject: pigeonMap['subject'] as String?,
      messageBody: pigeonMap['messageBody'] as String?,
      type: pigeonMap['type'] as String?,
      hasMedia: pigeonMap['hasMedia'] as bool?,
      media: pigeonMap['media'] != null
          ? MessageMediaData.decode(pigeonMap['media']!)
          : null,
      conversationSid: pigeonMap['conversationSid'] as String?,
      participantSid: pigeonMap['participantSid'] as String?,
      dateCreated: pigeonMap['dateCreated'] as String?,
      dateUpdated: pigeonMap['dateUpdated'] as String?,
      lastUpdatedBy: pigeonMap['lastUpdatedBy'] as String?,
      attributes: pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null,
    );
  }
}

class MessageOptionsData {
  MessageOptionsData({
    this.body,
    this.attributes,
    this.mimeType,
    this.filename,
    this.inputPath,
    this.mediaProgressListenerId,
  });

  String? body;
  AttributesData? attributes;
  String? mimeType;
  String? filename;
  String? inputPath;
  int? mediaProgressListenerId;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['body'] = body;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['mimeType'] = mimeType;
    pigeonMap['filename'] = filename;
    pigeonMap['inputPath'] = inputPath;
    pigeonMap['mediaProgressListenerId'] = mediaProgressListenerId;
    return pigeonMap;
  }

  static MessageOptionsData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageOptionsData(
      body: pigeonMap['body'] as String?,
      attributes: pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null,
      mimeType: pigeonMap['mimeType'] as String?,
      filename: pigeonMap['filename'] as String?,
      inputPath: pigeonMap['inputPath'] as String?,
      mediaProgressListenerId: pigeonMap['mediaProgressListenerId'] as int?,
    );
  }
}

class ParticipantData {
  ParticipantData({
    this.sid,
    this.conversationSid,
    this.type,
    this.attributes,
    this.dateCreated,
    this.dateUpdated,
    this.identity,
    this.lastReadMessageIndex,
    this.lastReadTimestamp,
  });

  String? sid;
  String? conversationSid;
  String? type;
  AttributesData? attributes;
  String? dateCreated;
  String? dateUpdated;
  String? identity;
  int? lastReadMessageIndex;
  String? lastReadTimestamp;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['conversationSid'] = conversationSid;
    pigeonMap['type'] = type;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['dateCreated'] = dateCreated;
    pigeonMap['dateUpdated'] = dateUpdated;
    pigeonMap['identity'] = identity;
    pigeonMap['lastReadMessageIndex'] = lastReadMessageIndex;
    pigeonMap['lastReadTimestamp'] = lastReadTimestamp;
    return pigeonMap;
  }

  static ParticipantData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ParticipantData(
      sid: pigeonMap['sid'] as String?,
      conversationSid: pigeonMap['conversationSid'] as String?,
      type: pigeonMap['type'] as String?,
      attributes: pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null,
      dateCreated: pigeonMap['dateCreated'] as String?,
      dateUpdated: pigeonMap['dateUpdated'] as String?,
      identity: pigeonMap['identity'] as String?,
      lastReadMessageIndex: pigeonMap['lastReadMessageIndex'] as int?,
      lastReadTimestamp: pigeonMap['lastReadTimestamp'] as String?,
    );
  }
}

class DeliveryReceiptData {
  DeliveryReceiptData({
    this.total,
    this.read,
    this.undelivered,
    this.delivered,
    this.failed,
    this.sent,
  });

  int? total;
  String? read;
  String? undelivered;
  String? delivered;
  String? failed;
  String? sent;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['total'] = total;
    pigeonMap['read'] = read;
    pigeonMap['undelivered'] = undelivered;
    pigeonMap['delivered'] = delivered;
    pigeonMap['failed'] = failed;
    pigeonMap['sent'] = sent;
    return pigeonMap;
  }

  static DeliveryReceiptData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return DeliveryReceiptData(
      total: pigeonMap['total'] as int?,
      read: pigeonMap['read'] as String?,
      undelivered: pigeonMap['undelivered'] as String?,
      delivered: pigeonMap['delivered'] as String?,
      failed: pigeonMap['failed'] as String?,
      sent: pigeonMap['sent'] as String?,
    );
  }
}

class DetailedDeliveryReceiptData {
  DetailedDeliveryReceiptData({
    this.conversationSid,
    this.channelMessageSid,
    this.dateCreatedAsDate,
    this.dateUpdatedAsDate,
    this.errorCode,
    this.messageSid,
    this.participantSid,
    this.sid,
  });

  String? conversationSid;
  String? channelMessageSid;
  String? dateCreatedAsDate;
  String? dateUpdatedAsDate;
  int? errorCode;
  String? messageSid;
  String? participantSid;
  String? sid;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['conversationSid'] = conversationSid;
    pigeonMap['channelMessageSid'] = channelMessageSid;
    pigeonMap['dateCreatedAsDate'] = dateCreatedAsDate;
    pigeonMap['dateUpdatedAsDate'] = dateUpdatedAsDate;
    pigeonMap['errorCode'] = errorCode;
    pigeonMap['messageSid'] = messageSid;
    pigeonMap['participantSid'] = participantSid;
    pigeonMap['sid'] = sid;
    return pigeonMap;
  }

  static DetailedDeliveryReceiptData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return DetailedDeliveryReceiptData(
      conversationSid: pigeonMap['conversationSid'] as String?,
      channelMessageSid: pigeonMap['channelMessageSid'] as String?,
      dateCreatedAsDate: pigeonMap['dateCreatedAsDate'] as String?,
      dateUpdatedAsDate: pigeonMap['dateUpdatedAsDate'] as String?,
      errorCode: pigeonMap['errorCode'] as int?,
      messageSid: pigeonMap['messageSid'] as String?,
      participantSid: pigeonMap['participantSid'] as String?,
      sid: pigeonMap['sid'] as String?,
    );
  }
}

class UserData {
  UserData({
    this.identity,
    this.attributes,
    this.friendlyName,
    this.isNotifiable,
    this.isOnline,
    this.isSubscribed,
  });

  String? identity;
  AttributesData? attributes;
  String? friendlyName;
  bool? isNotifiable;
  bool? isOnline;
  bool? isSubscribed;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['identity'] = identity;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['friendlyName'] = friendlyName;
    pigeonMap['isNotifiable'] = isNotifiable;
    pigeonMap['isOnline'] = isOnline;
    pigeonMap['isSubscribed'] = isSubscribed;
    return pigeonMap;
  }

  static UserData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return UserData(
      identity: pigeonMap['identity'] as String?,
      attributes: pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null,
      friendlyName: pigeonMap['friendlyName'] as String?,
      isNotifiable: pigeonMap['isNotifiable'] as bool?,
      isOnline: pigeonMap['isOnline'] as bool?,
      isSubscribed: pigeonMap['isSubscribed'] as bool?,
    );
  }
}

class MessageCount {
  MessageCount({
    this.count,
  });

  int? count;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['count'] = count;
    return pigeonMap;
  }

  static MessageCount decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageCount(
      count: pigeonMap['count'] as int?,
    );
  }
}

class ConversationUpdatedData {
  ConversationUpdatedData({
    this.conversation,
    this.reason,
  });

  ConversationData? conversation;
  String? reason;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['conversation'] = conversation == null ? null : conversation!.encode();
    pigeonMap['reason'] = reason;
    return pigeonMap;
  }

  static ConversationUpdatedData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ConversationUpdatedData(
      conversation: pigeonMap['conversation'] != null
          ? ConversationData.decode(pigeonMap['conversation']!)
          : null,
      reason: pigeonMap['reason'] as String?,
    );
  }
}

class ErrorInfoData {
  ErrorInfoData({
    this.code,
    this.message,
    this.status,
  });

  int? code;
  String? message;
  int? status;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['code'] = code;
    pigeonMap['message'] = message;
    pigeonMap['status'] = status;
    return pigeonMap;
  }

  static ErrorInfoData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ErrorInfoData(
      code: pigeonMap['code'] as int?,
      message: pigeonMap['message'] as String?,
      status: pigeonMap['status'] as int?,
    );
  }
}

class _PluginApiCodec extends StandardMessageCodec {
  const _PluginApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ConversationClientData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is PropertiesData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return ConversationClientData.decode(readValue(buffer)!);
      
      case 129:       
        return PropertiesData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class PluginApi {
  /// Constructor for [PluginApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PluginApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PluginApiCodec();

  Future<void> debug(bool arg_enableNative, bool arg_enableSdk) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PluginApi.debug', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_enableNative, arg_enableSdk]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<ConversationClientData> create(String arg_jwtToken, PropertiesData arg_properties) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PluginApi.create', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_jwtToken, arg_properties]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ConversationClientData?)!;
    }
  }
}

class _ConversationClientApiCodec extends StandardMessageCodec {
  const _ConversationClientApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is ConversationData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is TokenData) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is UserData) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return AttributesData.decode(readValue(buffer)!);
      
      case 129:       
        return ConversationData.decode(readValue(buffer)!);
      
      case 130:       
        return TokenData.decode(readValue(buffer)!);
      
      case 131:       
        return UserData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class ConversationClientApi {
  /// Constructor for [ConversationClientApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ConversationClientApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ConversationClientApiCodec();

  Future<void> updateToken(String arg_token) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.updateToken', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_token]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> shutdown() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.shutdown', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<ConversationData> createConversation(String arg_friendlyName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.createConversation', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_friendlyName]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ConversationData?)!;
    }
  }

  Future<List<ConversationData?>> getMyConversations() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.getMyConversations', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<ConversationData?>();
    }
  }

  Future<ConversationData> getConversation(String arg_conversationSidOrUniqueName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.getConversation', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSidOrUniqueName]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ConversationData?)!;
    }
  }

  Future<UserData> getMyUser() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.getMyUser', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as UserData?)!;
    }
  }

  Future<void> registerForNotification(TokenData arg_tokenData) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.registerForNotification', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_tokenData]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> unregisterForNotification(TokenData arg_tokenData) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.unregisterForNotification', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_tokenData]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _ConversationApiCodec extends StandardMessageCodec {
  const _ConversationApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is MessageCount) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is MessageData) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is MessageMediaData) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is MessageOptionsData) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
    if (value is ParticipantData) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return AttributesData.decode(readValue(buffer)!);
      
      case 129:       
        return MessageCount.decode(readValue(buffer)!);
      
      case 130:       
        return MessageData.decode(readValue(buffer)!);
      
      case 131:       
        return MessageMediaData.decode(readValue(buffer)!);
      
      case 132:       
        return MessageOptionsData.decode(readValue(buffer)!);
      
      case 133:       
        return ParticipantData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class ConversationApi {
  /// Constructor for [ConversationApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ConversationApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ConversationApiCodec();

  Future<void> join(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.join', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> leave(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.leave', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> destroy(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.destroy', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> typing(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.typing', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<MessageData> sendMessage(String arg_conversationSid, MessageOptionsData arg_options) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.sendMessage', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_options]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as MessageData?)!;
    }
  }

  Future<bool> addParticipantByIdentity(String arg_conversationSid, String arg_identity) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.addParticipantByIdentity', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_identity]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<bool> removeParticipant(String arg_conversationSid, String arg_participantSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.removeParticipant', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_participantSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<bool> removeParticipantByIdentity(String arg_conversationSid, String arg_identity) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.removeParticipantByIdentity', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_identity]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<ParticipantData> getParticipantByIdentity(String arg_conversationSid, String arg_identity) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getParticipantByIdentity', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_identity]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ParticipantData?)!;
    }
  }

  Future<ParticipantData> getParticipantBySid(String arg_conversationSid, String arg_participantSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getParticipantBySid', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_participantSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ParticipantData?)!;
    }
  }

  Future<List<ParticipantData?>> getParticipantsList(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getParticipantsList', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<ParticipantData?>();
    }
  }

  Future<MessageCount> getMessagesCount(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getMessagesCount', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<int> getUnreadMessagesCount(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getUnreadMessagesCount', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as int?)!;
    }
  }

  Future<MessageCount> advanceLastReadMessageIndex(String arg_conversationSid, int arg_lastReadMessageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.advanceLastReadMessageIndex', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_lastReadMessageIndex]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<MessageCount> setLastReadMessageIndex(String arg_conversationSid, int arg_lastReadMessageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setLastReadMessageIndex', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_lastReadMessageIndex]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<MessageCount> setAllMessagesRead(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setAllMessagesRead', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<MessageCount> setAllMessagesUnread(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setAllMessagesUnread', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<int> getParticipantsCount(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getParticipantsCount', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as int?)!;
    }
  }

  Future<List<MessageData?>> getMessagesAfter(String arg_conversationSid, int arg_index, int arg_count) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getMessagesAfter', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_index, arg_count]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<MessageData?>();
    }
  }

  Future<List<MessageData?>> getMessagesBefore(String arg_conversationSid, int arg_index, int arg_count) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getMessagesBefore', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_index, arg_count]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<MessageData?>();
    }
  }

  Future<MessageData> getMessageByIndex(String arg_conversationSid, int arg_messageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getMessageByIndex', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as MessageData?)!;
    }
  }

  Future<List<MessageData?>> getLastMessages(String arg_conversationSid, int arg_count) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getLastMessages', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_count]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<MessageData?>();
    }
  }

  Future<bool> removeMessage(String arg_conversationSid, int arg_messageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.removeMessage', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<void> setAttributes(String arg_conversationSid, AttributesData arg_attributes) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setAttributes', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_attributes]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> setFriendlyName(String arg_conversationSid, String arg_friendlyName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setFriendlyName', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_friendlyName]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> setNotificationLevel(String arg_conversationSid, String arg_notificationLevel) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setNotificationLevel', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_notificationLevel]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> setUniqueName(String arg_conversationSid, String arg_uniqueName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setUniqueName', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_uniqueName]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _ParticipantApiCodec extends StandardMessageCodec {
  const _ParticipantApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is UserData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return AttributesData.decode(readValue(buffer)!);
      
      case 129:       
        return UserData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class ParticipantApi {
  /// Constructor for [ParticipantApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ParticipantApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ParticipantApiCodec();

  Future<UserData> getUser(String arg_conversationSid, String arg_participantSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ParticipantApi.getUser', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_participantSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as UserData?)!;
    }
  }

  Future<void> setAttributes(String arg_conversationSid, String arg_participantSid, AttributesData arg_attributes) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ParticipantApi.setAttributes', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_participantSid, arg_attributes]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> remove(String arg_conversationSid, String arg_participantSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ParticipantApi.remove', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_participantSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _MessageApiCodec extends StandardMessageCodec {
  const _MessageApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is DeliveryReceiptData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is DetailedDeliveryReceiptData) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is ParticipantData) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return AttributesData.decode(readValue(buffer)!);
      
      case 129:       
        return DeliveryReceiptData.decode(readValue(buffer)!);
      
      case 130:       
        return DetailedDeliveryReceiptData.decode(readValue(buffer)!);
      
      case 131:       
        return ParticipantData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class MessageApi {
  /// Constructor for [MessageApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MessageApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _MessageApiCodec();

  Future<String> getMediaContentTemporaryUrl(String arg_conversationSid, int arg_messageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.getMediaContentTemporaryUrl', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as String?)!;
    }
  }

  Future<ParticipantData> getParticipant(String arg_conversationSid, int arg_messageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.getParticipant', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ParticipantData?)!;
    }
  }

  Future<void> setAttributes(String arg_conversationSid, int arg_messageIndex, AttributesData arg_attributes) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.setAttributes', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex, arg_attributes]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> updateMessageBody(String arg_conversationSid, int arg_messageIndex, String arg_messageBody) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.updateMessageBody', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex, arg_messageBody]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<DeliveryReceiptData> getAggregatedDeliveryReceipt(String arg_conversationSid, int arg_messageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.getAggregatedDeliveryReceipt', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as DeliveryReceiptData?)!;
    }
  }

  Future<List<DetailedDeliveryReceiptData?>> getDetailedDeliveryReceiptList(String arg_conversationSid, int arg_messageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.getDetailedDeliveryReceiptList', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<DetailedDeliveryReceiptData?>();
    }
  }
}

class _UserApiCodec extends StandardMessageCodec {
  const _UserApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return AttributesData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class UserApi {
  /// Constructor for [UserApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UserApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _UserApiCodec();

  Future<void> setFriendlyName(String arg_identity, String arg_friendlyName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UserApi.setFriendlyName', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_identity, arg_friendlyName]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> setAttributes(String arg_identity, AttributesData arg_attributes) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UserApi.setAttributes', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_identity, arg_attributes]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _FlutterConversationClientApiCodec extends StandardMessageCodec {
  const _FlutterConversationClientApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is ConversationData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is ConversationUpdatedData) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is ErrorInfoData) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is MessageData) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
    if (value is MessageMediaData) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else 
    if (value is ParticipantData) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else 
    if (value is UserData) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return AttributesData.decode(readValue(buffer)!);
      
      case 129:       
        return ConversationData.decode(readValue(buffer)!);
      
      case 130:       
        return ConversationUpdatedData.decode(readValue(buffer)!);
      
      case 131:       
        return ErrorInfoData.decode(readValue(buffer)!);
      
      case 132:       
        return MessageData.decode(readValue(buffer)!);
      
      case 133:       
        return MessageMediaData.decode(readValue(buffer)!);
      
      case 134:       
        return ParticipantData.decode(readValue(buffer)!);
      
      case 135:       
        return UserData.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class FlutterConversationClientApi {
  static const MessageCodec<Object?> codec = _FlutterConversationClientApiCodec();

  void error(ErrorInfoData errorInfoData);
  void conversationAdded(ConversationData conversationData);
  void conversationUpdated(ConversationUpdatedData event);
  void conversationDeleted(ConversationData conversationData);
  void clientSynchronization(String synchronizationStatus);
  void conversationSynchronizationChange(ConversationData conversationData);
  void connectionStateChange(String connectionState);
  void tokenAboutToExpire();
  void tokenExpired();
  void userSubscribed(UserData userData);
  void userUnsubscribed(UserData userData);
  void userUpdated(UserData userData, String reason);
  void addedToConversationNotification(String conversationSid);
  void newMessageNotification(String conversationSid, int messageIndex);
  void notificationSubscribed();
  void notificationFailed(ErrorInfoData errorInfoData);
  void removedFromConversationNotification(String conversationSid);
  void registered();
  void registrationFailed(ErrorInfoData errorInfoData);
  void deregistered();
  void deregistrationFailed(ErrorInfoData errorInfoData);
  void messageAdded(String conversationSid, MessageData messageData);
  void messageUpdated(String conversationSid, MessageData messageData, String reason);
  void messageDeleted(String conversationSid, MessageData messageData);
  void participantAdded(String conversationSid, ParticipantData participantData);
  void participantUpdated(String conversationSid, ParticipantData participantData, String reason);
  void participantDeleted(String conversationSid, ParticipantData participantData);
  void typingStarted(String conversationSid, ConversationData conversationData, ParticipantData participantData);
  void typingEnded(String conversationSid, ConversationData conversationData, ParticipantData participantData);
  void synchronizationChanged(String conversationSid, ConversationData conversationData);
  static void setup(FlutterConversationClientApi? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.error', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.error was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ErrorInfoData? arg_errorInfoData = (args[0] as ErrorInfoData?);
          assert(arg_errorInfoData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.error was null, expected non-null ErrorInfoData.');
          api.error(arg_errorInfoData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.conversationAdded', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationAdded was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ConversationData? arg_conversationData = (args[0] as ConversationData?);
          assert(arg_conversationData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationAdded was null, expected non-null ConversationData.');
          api.conversationAdded(arg_conversationData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.conversationUpdated', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ConversationUpdatedData? arg_event = (args[0] as ConversationUpdatedData?);
          assert(arg_event != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationUpdated was null, expected non-null ConversationUpdatedData.');
          api.conversationUpdated(arg_event!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.conversationDeleted', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationDeleted was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ConversationData? arg_conversationData = (args[0] as ConversationData?);
          assert(arg_conversationData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationDeleted was null, expected non-null ConversationData.');
          api.conversationDeleted(arg_conversationData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.clientSynchronization', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.clientSynchronization was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_synchronizationStatus = (args[0] as String?);
          assert(arg_synchronizationStatus != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.clientSynchronization was null, expected non-null String.');
          api.clientSynchronization(arg_synchronizationStatus!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.conversationSynchronizationChange', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationSynchronizationChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ConversationData? arg_conversationData = (args[0] as ConversationData?);
          assert(arg_conversationData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationSynchronizationChange was null, expected non-null ConversationData.');
          api.conversationSynchronizationChange(arg_conversationData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.connectionStateChange', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.connectionStateChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_connectionState = (args[0] as String?);
          assert(arg_connectionState != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.connectionStateChange was null, expected non-null String.');
          api.connectionStateChange(arg_connectionState!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.tokenAboutToExpire', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.tokenAboutToExpire();
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.tokenExpired', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.tokenExpired();
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.userSubscribed', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userSubscribed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final UserData? arg_userData = (args[0] as UserData?);
          assert(arg_userData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userSubscribed was null, expected non-null UserData.');
          api.userSubscribed(arg_userData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.userUnsubscribed', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userUnsubscribed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final UserData? arg_userData = (args[0] as UserData?);
          assert(arg_userData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userUnsubscribed was null, expected non-null UserData.');
          api.userUnsubscribed(arg_userData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.userUpdated', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final UserData? arg_userData = (args[0] as UserData?);
          assert(arg_userData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userUpdated was null, expected non-null UserData.');
          final String? arg_reason = (args[1] as String?);
          assert(arg_reason != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userUpdated was null, expected non-null String.');
          api.userUpdated(arg_userData!, arg_reason!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.addedToConversationNotification', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.addedToConversationNotification was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.addedToConversationNotification was null, expected non-null String.');
          api.addedToConversationNotification(arg_conversationSid!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.newMessageNotification', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.newMessageNotification was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.newMessageNotification was null, expected non-null String.');
          final int? arg_messageIndex = (args[1] as int?);
          assert(arg_messageIndex != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.newMessageNotification was null, expected non-null int.');
          api.newMessageNotification(arg_conversationSid!, arg_messageIndex!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.notificationSubscribed', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.notificationSubscribed();
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.notificationFailed', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.notificationFailed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ErrorInfoData? arg_errorInfoData = (args[0] as ErrorInfoData?);
          assert(arg_errorInfoData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.notificationFailed was null, expected non-null ErrorInfoData.');
          api.notificationFailed(arg_errorInfoData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.removedFromConversationNotification', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.removedFromConversationNotification was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.removedFromConversationNotification was null, expected non-null String.');
          api.removedFromConversationNotification(arg_conversationSid!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.registered', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.registered();
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.registrationFailed', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.registrationFailed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ErrorInfoData? arg_errorInfoData = (args[0] as ErrorInfoData?);
          assert(arg_errorInfoData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.registrationFailed was null, expected non-null ErrorInfoData.');
          api.registrationFailed(arg_errorInfoData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.deregistered', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.deregistered();
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.deregistrationFailed', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.deregistrationFailed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ErrorInfoData? arg_errorInfoData = (args[0] as ErrorInfoData?);
          assert(arg_errorInfoData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.deregistrationFailed was null, expected non-null ErrorInfoData.');
          api.deregistrationFailed(arg_errorInfoData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.messageAdded', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageAdded was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageAdded was null, expected non-null String.');
          final MessageData? arg_messageData = (args[1] as MessageData?);
          assert(arg_messageData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageAdded was null, expected non-null MessageData.');
          api.messageAdded(arg_conversationSid!, arg_messageData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.messageUpdated', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageUpdated was null, expected non-null String.');
          final MessageData? arg_messageData = (args[1] as MessageData?);
          assert(arg_messageData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageUpdated was null, expected non-null MessageData.');
          final String? arg_reason = (args[2] as String?);
          assert(arg_reason != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageUpdated was null, expected non-null String.');
          api.messageUpdated(arg_conversationSid!, arg_messageData!, arg_reason!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.messageDeleted', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageDeleted was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageDeleted was null, expected non-null String.');
          final MessageData? arg_messageData = (args[1] as MessageData?);
          assert(arg_messageData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageDeleted was null, expected non-null MessageData.');
          api.messageDeleted(arg_conversationSid!, arg_messageData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.participantAdded', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantAdded was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantAdded was null, expected non-null String.');
          final ParticipantData? arg_participantData = (args[1] as ParticipantData?);
          assert(arg_participantData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantAdded was null, expected non-null ParticipantData.');
          api.participantAdded(arg_conversationSid!, arg_participantData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.participantUpdated', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantUpdated was null, expected non-null String.');
          final ParticipantData? arg_participantData = (args[1] as ParticipantData?);
          assert(arg_participantData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantUpdated was null, expected non-null ParticipantData.');
          final String? arg_reason = (args[2] as String?);
          assert(arg_reason != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantUpdated was null, expected non-null String.');
          api.participantUpdated(arg_conversationSid!, arg_participantData!, arg_reason!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.participantDeleted', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantDeleted was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantDeleted was null, expected non-null String.');
          final ParticipantData? arg_participantData = (args[1] as ParticipantData?);
          assert(arg_participantData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantDeleted was null, expected non-null ParticipantData.');
          api.participantDeleted(arg_conversationSid!, arg_participantData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.typingStarted', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingStarted was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingStarted was null, expected non-null String.');
          final ConversationData? arg_conversationData = (args[1] as ConversationData?);
          assert(arg_conversationData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingStarted was null, expected non-null ConversationData.');
          final ParticipantData? arg_participantData = (args[2] as ParticipantData?);
          assert(arg_participantData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingStarted was null, expected non-null ParticipantData.');
          api.typingStarted(arg_conversationSid!, arg_conversationData!, arg_participantData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.typingEnded', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingEnded was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingEnded was null, expected non-null String.');
          final ConversationData? arg_conversationData = (args[1] as ConversationData?);
          assert(arg_conversationData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingEnded was null, expected non-null ConversationData.');
          final ParticipantData? arg_participantData = (args[2] as ParticipantData?);
          assert(arg_participantData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingEnded was null, expected non-null ParticipantData.');
          api.typingEnded(arg_conversationSid!, arg_conversationData!, arg_participantData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.synchronizationChanged', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.synchronizationChanged was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = (args[0] as String?);
          assert(arg_conversationSid != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.synchronizationChanged was null, expected non-null String.');
          final ConversationData? arg_conversationData = (args[1] as ConversationData?);
          assert(arg_conversationData != null, 'Argument for dev.flutter.pigeon.FlutterConversationClientApi.synchronizationChanged was null, expected non-null ConversationData.');
          api.synchronizationChanged(arg_conversationSid!, arg_conversationData!);
          return;
        });
      }
    }
  }
}

class _FlutterLoggingApiCodec extends StandardMessageCodec {
  const _FlutterLoggingApiCodec();
}
abstract class FlutterLoggingApi {
  static const MessageCodec<Object?> codec = _FlutterLoggingApiCodec();

  void logFromHost(String msg);
  static void setup(FlutterLoggingApi? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterLoggingApi.logFromHost', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterLoggingApi.logFromHost was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_msg = (args[0] as String?);
          assert(arg_msg != null, 'Argument for dev.flutter.pigeon.FlutterLoggingApi.logFromHost was null, expected non-null String.');
          api.logFromHost(arg_msg!);
          return;
        });
      }
    }
  }
}
