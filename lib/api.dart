// Autogenerated from Pigeon (v1.0.7), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name
// @dart = 2.12
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/foundation.dart' show WriteBuffer, ReadBuffer;
import 'package:flutter/services.dart';

class ConversationClientData {
  String? myIdentity;
  String? connectionState;
  bool? isReachabilityEnabled;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['myIdentity'] = myIdentity;
    pigeonMap['connectionState'] = connectionState;
    pigeonMap['isReachabilityEnabled'] = isReachabilityEnabled;
    return pigeonMap;
  }

  static ConversationClientData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ConversationClientData()
      ..myIdentity = pigeonMap['myIdentity'] as String?
      ..connectionState = pigeonMap['connectionState'] as String?
      ..isReachabilityEnabled = pigeonMap['isReachabilityEnabled'] as bool?;
  }
}

class PropertiesData {
  String? region;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['region'] = region;
    return pigeonMap;
  }

  static PropertiesData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PropertiesData()..region = pigeonMap['region'] as String?;
  }
}

class ConversationData {
  String? sid;
  AttributesData? attributes;
  String? uniqueName;
  String? friendlyName;
  String? status;
  String? synchronizationStatus;
  String? dateCreated;
  String? createdBy;
  String? dateUpdated;
  String? lastMessageDate;
  int? lastReadMessageIndex;
  int? lastMessageIndex;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['uniqueName'] = uniqueName;
    pigeonMap['friendlyName'] = friendlyName;
    pigeonMap['status'] = status;
    pigeonMap['synchronizationStatus'] = synchronizationStatus;
    pigeonMap['dateCreated'] = dateCreated;
    pigeonMap['createdBy'] = createdBy;
    pigeonMap['dateUpdated'] = dateUpdated;
    pigeonMap['lastMessageDate'] = lastMessageDate;
    pigeonMap['lastReadMessageIndex'] = lastReadMessageIndex;
    pigeonMap['lastMessageIndex'] = lastMessageIndex;
    return pigeonMap;
  }

  static ConversationData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ConversationData()
      ..sid = pigeonMap['sid'] as String?
      ..attributes = pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null
      ..uniqueName = pigeonMap['uniqueName'] as String?
      ..friendlyName = pigeonMap['friendlyName'] as String?
      ..status = pigeonMap['status'] as String?
      ..synchronizationStatus = pigeonMap['synchronizationStatus'] as String?
      ..dateCreated = pigeonMap['dateCreated'] as String?
      ..createdBy = pigeonMap['createdBy'] as String?
      ..dateUpdated = pigeonMap['dateUpdated'] as String?
      ..lastMessageDate = pigeonMap['lastMessageDate'] as String?
      ..lastReadMessageIndex = pigeonMap['lastReadMessageIndex'] as int?
      ..lastMessageIndex = pigeonMap['lastMessageIndex'] as int?;
  }
}

class AttributesData {
  String? type;
  String? data;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['type'] = type;
    pigeonMap['data'] = data;
    return pigeonMap;
  }

  static AttributesData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return AttributesData()
      ..type = pigeonMap['type'] as String?
      ..data = pigeonMap['data'] as String?;
  }
}

class TokenData {
  String? token;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['token'] = token;
    return pigeonMap;
  }

  static TokenData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return TokenData()..token = pigeonMap['token'] as String?;
  }
}

class MessageMediaData {
  String? sid;
  String? fileName;
  String? type;
  int? size;
  String? conversationSid;
  String? messageSid;
  int? messageIndex;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['fileName'] = fileName;
    pigeonMap['type'] = type;
    pigeonMap['size'] = size;
    pigeonMap['conversationSid'] = conversationSid;
    pigeonMap['messageSid'] = messageSid;
    pigeonMap['messageIndex'] = messageIndex;
    return pigeonMap;
  }

  static MessageMediaData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageMediaData()
      ..sid = pigeonMap['sid'] as String?
      ..fileName = pigeonMap['fileName'] as String?
      ..type = pigeonMap['type'] as String?
      ..size = pigeonMap['size'] as int?
      ..conversationSid = pigeonMap['conversationSid'] as String?
      ..messageSid = pigeonMap['messageSid'] as String?
      ..messageIndex = pigeonMap['messageIndex'] as int?;
  }
}

class MessageData {
  String? sid;
  int? messageIndex;
  String? author;
  String? subject;
  String? messageBody;
  String? type;
  bool? hasMedia;
  MessageMediaData? media;
  String? conversationSid;
  String? participantSid;
  String? dateCreated;
  String? dateUpdated;
  String? lastUpdatedBy;
  AttributesData? attributes;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['messageIndex'] = messageIndex;
    pigeonMap['author'] = author;
    pigeonMap['subject'] = subject;
    pigeonMap['messageBody'] = messageBody;
    pigeonMap['type'] = type;
    pigeonMap['hasMedia'] = hasMedia;
    pigeonMap['media'] = media == null ? null : media!.encode();
    pigeonMap['conversationSid'] = conversationSid;
    pigeonMap['participantSid'] = participantSid;
    pigeonMap['dateCreated'] = dateCreated;
    pigeonMap['dateUpdated'] = dateUpdated;
    pigeonMap['lastUpdatedBy'] = lastUpdatedBy;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    return pigeonMap;
  }

  static MessageData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageData()
      ..sid = pigeonMap['sid'] as String?
      ..messageIndex = pigeonMap['messageIndex'] as int?
      ..author = pigeonMap['author'] as String?
      ..subject = pigeonMap['subject'] as String?
      ..messageBody = pigeonMap['messageBody'] as String?
      ..type = pigeonMap['type'] as String?
      ..hasMedia = pigeonMap['hasMedia'] as bool?
      ..media = pigeonMap['media'] != null
          ? MessageMediaData.decode(pigeonMap['media']!)
          : null
      ..conversationSid = pigeonMap['conversationSid'] as String?
      ..participantSid = pigeonMap['participantSid'] as String?
      ..dateCreated = pigeonMap['dateCreated'] as String?
      ..dateUpdated = pigeonMap['dateUpdated'] as String?
      ..lastUpdatedBy = pigeonMap['lastUpdatedBy'] as String?
      ..attributes = pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null;
  }
}

class MessageOptionsData {
  String? body;
  AttributesData? attributes;
  String? mimeType;
  String? filename;
  String? inputPath;
  int? mediaProgressListenerId;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['body'] = body;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['mimeType'] = mimeType;
    pigeonMap['filename'] = filename;
    pigeonMap['inputPath'] = inputPath;
    pigeonMap['mediaProgressListenerId'] = mediaProgressListenerId;
    return pigeonMap;
  }

  static MessageOptionsData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageOptionsData()
      ..body = pigeonMap['body'] as String?
      ..attributes = pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null
      ..mimeType = pigeonMap['mimeType'] as String?
      ..filename = pigeonMap['filename'] as String?
      ..inputPath = pigeonMap['inputPath'] as String?
      ..mediaProgressListenerId = pigeonMap['mediaProgressListenerId'] as int?;
  }
}

class ParticipantData {
  String? sid;
  String? conversationSid;
  String? type;
  AttributesData? attributes;
  String? dateCreated;
  String? dateUpdated;
  String? identity;
  int? lastReadMessageIndex;
  String? lastReadTimestamp;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['sid'] = sid;
    pigeonMap['conversationSid'] = conversationSid;
    pigeonMap['type'] = type;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['dateCreated'] = dateCreated;
    pigeonMap['dateUpdated'] = dateUpdated;
    pigeonMap['identity'] = identity;
    pigeonMap['lastReadMessageIndex'] = lastReadMessageIndex;
    pigeonMap['lastReadTimestamp'] = lastReadTimestamp;
    return pigeonMap;
  }

  static ParticipantData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ParticipantData()
      ..sid = pigeonMap['sid'] as String?
      ..conversationSid = pigeonMap['conversationSid'] as String?
      ..type = pigeonMap['type'] as String?
      ..attributes = pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null
      ..dateCreated = pigeonMap['dateCreated'] as String?
      ..dateUpdated = pigeonMap['dateUpdated'] as String?
      ..identity = pigeonMap['identity'] as String?
      ..lastReadMessageIndex = pigeonMap['lastReadMessageIndex'] as int?
      ..lastReadTimestamp = pigeonMap['lastReadTimestamp'] as String?;
  }
}

class UserData {
  String? identity;
  AttributesData? attributes;
  String? friendlyName;
  bool? isNotifiable;
  bool? isOnline;
  bool? isSubscribed;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['identity'] = identity;
    pigeonMap['attributes'] = attributes == null ? null : attributes!.encode();
    pigeonMap['friendlyName'] = friendlyName;
    pigeonMap['isNotifiable'] = isNotifiable;
    pigeonMap['isOnline'] = isOnline;
    pigeonMap['isSubscribed'] = isSubscribed;
    return pigeonMap;
  }

  static UserData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return UserData()
      ..identity = pigeonMap['identity'] as String?
      ..attributes = pigeonMap['attributes'] != null
          ? AttributesData.decode(pigeonMap['attributes']!)
          : null
      ..friendlyName = pigeonMap['friendlyName'] as String?
      ..isNotifiable = pigeonMap['isNotifiable'] as bool?
      ..isOnline = pigeonMap['isOnline'] as bool?
      ..isSubscribed = pigeonMap['isSubscribed'] as bool?;
  }
}

class MessageCount {
  int? count;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['count'] = count;
    return pigeonMap;
  }

  static MessageCount decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return MessageCount()..count = pigeonMap['count'] as int?;
  }
}

class ConversationUpdatedData {
  ConversationData? conversation;
  String? reason;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['conversation'] =
        conversation == null ? null : conversation!.encode();
    pigeonMap['reason'] = reason;
    return pigeonMap;
  }

  static ConversationUpdatedData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ConversationUpdatedData()
      ..conversation = pigeonMap['conversation'] != null
          ? ConversationData.decode(pigeonMap['conversation']!)
          : null
      ..reason = pigeonMap['reason'] as String?;
  }
}

class ErrorInfoData {
  int? code;
  String? message;
  int? status;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['code'] = code;
    pigeonMap['message'] = message;
    pigeonMap['status'] = status;
    return pigeonMap;
  }

  static ErrorInfoData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ErrorInfoData()
      ..code = pigeonMap['code'] as int?
      ..message = pigeonMap['message'] as String?
      ..status = pigeonMap['status'] as int?;
  }
}

class _PluginApiCodec extends StandardMessageCodec {
  const _PluginApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ConversationClientData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is PropertiesData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return ConversationClientData.decode(readValue(buffer)!);

      case 129:
        return PropertiesData.decode(readValue(buffer)!);

      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class PluginApi {
  /// Constructor for [PluginApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PluginApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PluginApiCodec();

  Future<void> debug(bool arg_enableNative, bool arg_enableSdk) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PluginApi.debug', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_enableNative, arg_enableSdk])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<ConversationClientData> create(
      String arg_jwtToken, PropertiesData arg_properties) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PluginApi.create', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_jwtToken, arg_properties]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as ConversationClientData?)!;
    }
  }
}

class _ConversationClientApiCodec extends StandardMessageCodec {
  const _ConversationClientApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is AttributesData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is ConversationData) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is ConversationData) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is ConversationData) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is TokenData) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is TokenData) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is UserData) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return AttributesData.decode(readValue(buffer)!);

      case 129:
        return AttributesData.decode(readValue(buffer)!);

      case 130:
        return ConversationData.decode(readValue(buffer)!);

      case 131:
        return ConversationData.decode(readValue(buffer)!);

      case 132:
        return ConversationData.decode(readValue(buffer)!);

      case 133:
        return TokenData.decode(readValue(buffer)!);

      case 134:
        return TokenData.decode(readValue(buffer)!);

      case 135:
        return UserData.decode(readValue(buffer)!);

      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class ConversationClientApi {
  /// Constructor for [ConversationClientApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ConversationClientApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ConversationClientApiCodec();

  Future<void> updateToken(String arg_token) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.updateToken', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_token]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> shutdown() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.shutdown', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<ConversationData> createConversation(String arg_friendlyName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.createConversation', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_friendlyName]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as ConversationData?)!;
    }
  }

  Future<List<ConversationData?>> getMyConversations() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.getMyConversations', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<ConversationData?>();
    }
  }

  Future<ConversationData> getConversation(
      String arg_conversationSidOrUniqueName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.getConversation', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSidOrUniqueName])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as ConversationData?)!;
    }
  }

  Future<UserData> getMyUser() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.getMyUser', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as UserData?)!;
    }
  }

  Future<void> registerForNotification(TokenData arg_tokenData) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.registerForNotification',
        codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_tokenData]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> unregisterForNotification(TokenData arg_tokenData) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationClientApi.unregisterForNotification',
        codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_tokenData]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _ConversationApiCodec extends StandardMessageCodec {
  const _ConversationApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is MessageCount) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is MessageCount) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is MessageCount) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is MessageCount) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is MessageCount) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is MessageData) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is MessageData) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else if (value is MessageData) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    } else if (value is MessageData) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    } else if (value is MessageData) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else if (value is MessageMediaData) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else if (value is MessageOptionsData) {
      buffer.putUint8(140);
      writeValue(buffer, value.encode());
    } else if (value is ParticipantData) {
      buffer.putUint8(141);
      writeValue(buffer, value.encode());
    } else if (value is ParticipantData) {
      buffer.putUint8(142);
      writeValue(buffer, value.encode());
    } else if (value is ParticipantData) {
      buffer.putUint8(143);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return AttributesData.decode(readValue(buffer)!);

      case 129:
        return MessageCount.decode(readValue(buffer)!);

      case 130:
        return MessageCount.decode(readValue(buffer)!);

      case 131:
        return MessageCount.decode(readValue(buffer)!);

      case 132:
        return MessageCount.decode(readValue(buffer)!);

      case 133:
        return MessageCount.decode(readValue(buffer)!);

      case 134:
        return MessageData.decode(readValue(buffer)!);

      case 135:
        return MessageData.decode(readValue(buffer)!);

      case 136:
        return MessageData.decode(readValue(buffer)!);

      case 137:
        return MessageData.decode(readValue(buffer)!);

      case 138:
        return MessageData.decode(readValue(buffer)!);

      case 139:
        return MessageMediaData.decode(readValue(buffer)!);

      case 140:
        return MessageOptionsData.decode(readValue(buffer)!);

      case 141:
        return ParticipantData.decode(readValue(buffer)!);

      case 142:
        return ParticipantData.decode(readValue(buffer)!);

      case 143:
        return ParticipantData.decode(readValue(buffer)!);

      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class ConversationApi {
  /// Constructor for [ConversationApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ConversationApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ConversationApiCodec();

  Future<void> join(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.join', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> leave(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.leave', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> destroy(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.destroy', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> typing(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.typing', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<MessageData> sendMessage(
      String arg_conversationSid, MessageOptionsData arg_options) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.sendMessage', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_options])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageData?)!;
    }
  }

  Future<bool> addParticipantByIdentity(
      String arg_conversationSid, String arg_identity) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.addParticipantByIdentity', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_identity])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<bool> removeParticipant(
      String arg_conversationSid, String arg_participantSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.removeParticipant', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_participantSid])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<bool> removeParticipantByIdentity(
      String arg_conversationSid, String arg_identity) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.removeParticipantByIdentity', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_identity])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<ParticipantData> getParticipantByIdentity(
      String arg_conversationSid, String arg_identity) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getParticipantByIdentity', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_identity])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as ParticipantData?)!;
    }
  }

  Future<ParticipantData> getParticipantBySid(
      String arg_conversationSid, String arg_participantSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getParticipantBySid', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_participantSid])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as ParticipantData?)!;
    }
  }

  Future<List<ParticipantData?>> getParticipantsList(
      String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getParticipantsList', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<ParticipantData?>();
    }
  }

  Future<MessageCount> getMessagesCount(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getMessagesCount', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<int> getUnreadMessagesCount(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getUnreadMessagesCount', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as int?)!;
    }
  }

  Future<MessageCount> advanceLastReadMessageIndex(
      String arg_conversationSid, int arg_lastReadMessageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.advanceLastReadMessageIndex', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
            .send(<Object>[arg_conversationSid, arg_lastReadMessageIndex])
        as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<MessageCount> setLastReadMessageIndex(
      String arg_conversationSid, int arg_lastReadMessageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setLastReadMessageIndex', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
            .send(<Object>[arg_conversationSid, arg_lastReadMessageIndex])
        as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<MessageCount> setAllMessagesRead(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setAllMessagesRead', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<MessageCount> setAllMessagesUnread(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setAllMessagesUnread', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageCount?)!;
    }
  }

  Future<int> getParticipantsCount(String arg_conversationSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getParticipantsCount', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_conversationSid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as int?)!;
    }
  }

  Future<List<MessageData?>> getMessagesAfter(
      String arg_conversationSid, int arg_index, int arg_count) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getMessagesAfter', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_index, arg_count])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<MessageData?>();
    }
  }

  Future<List<MessageData?>> getMessagesBefore(
      String arg_conversationSid, int arg_index, int arg_count) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getMessagesBefore', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_index, arg_count])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<MessageData?>();
    }
  }

  Future<MessageData> getMessageByIndex(
      String arg_conversationSid, int arg_messageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getMessageByIndex', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as MessageData?)!;
    }
  }

  Future<List<MessageData?>> getLastMessages(
      String arg_conversationSid, int arg_count) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.getLastMessages', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_count])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as List<Object?>?)!.cast<MessageData?>();
    }
  }

  Future<bool> removeMessage(
      String arg_conversationSid, int arg_messageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.removeMessage', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<void> setAttributes(
      String arg_conversationSid, AttributesData arg_attributes) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setAttributes', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_attributes])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> setFriendlyName(
      String arg_conversationSid, String arg_friendlyName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setFriendlyName', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_friendlyName])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> setNotificationLevel(
      String arg_conversationSid, String arg_notificationLevel) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setNotificationLevel', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_notificationLevel])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> setUniqueName(
      String arg_conversationSid, String arg_uniqueName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConversationApi.setUniqueName', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_uniqueName])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _ParticipantApiCodec extends StandardMessageCodec {
  const _ParticipantApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is UserData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return AttributesData.decode(readValue(buffer)!);

      case 129:
        return UserData.decode(readValue(buffer)!);

      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class ParticipantApi {
  /// Constructor for [ParticipantApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ParticipantApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ParticipantApiCodec();

  Future<UserData> getUser(
      String arg_conversationSid, String arg_participantSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ParticipantApi.getUser', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_participantSid])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as UserData?)!;
    }
  }

  Future<void> setAttributes(String arg_conversationSid,
      String arg_participantSid, AttributesData arg_attributes) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ParticipantApi.setAttributes', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel.send(
            <Object>[arg_conversationSid, arg_participantSid, arg_attributes])
        as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> remove(
      String arg_conversationSid, String arg_participantSid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ParticipantApi.remove', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_participantSid])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _MessageApiCodec extends StandardMessageCodec {
  const _MessageApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is ParticipantData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return AttributesData.decode(readValue(buffer)!);

      case 129:
        return ParticipantData.decode(readValue(buffer)!);

      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class MessageApi {
  /// Constructor for [MessageApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MessageApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _MessageApiCodec();

  Future<String> getMediaContentTemporaryUrl(
      String arg_conversationSid, int arg_messageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.getMediaContentTemporaryUrl', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as String?)!;
    }
  }

  Future<ParticipantData> getParticipant(
      String arg_conversationSid, int arg_messageIndex) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.getParticipant', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_conversationSid, arg_messageIndex])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as ParticipantData?)!;
    }
  }

  Future<void> setAttributes(String arg_conversationSid, int arg_messageIndex,
      AttributesData arg_attributes) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.setAttributes', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel.send(
            <Object>[arg_conversationSid, arg_messageIndex, arg_attributes])
        as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> updateMessageBody(String arg_conversationSid,
      int arg_messageIndex, String arg_messageBody) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MessageApi.updateMessageBody', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel.send(
            <Object>[arg_conversationSid, arg_messageIndex, arg_messageBody])
        as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _UserApiCodec extends StandardMessageCodec {
  const _UserApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return AttributesData.decode(readValue(buffer)!);

      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class UserApi {
  /// Constructor for [UserApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UserApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _UserApiCodec();

  Future<void> setFriendlyName(
      String arg_identity, String arg_friendlyName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UserApi.setFriendlyName', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_identity, arg_friendlyName])
            as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> setAttributes(
      String arg_identity, AttributesData arg_attributes) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UserApi.setAttributes', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap = await channel
        .send(<Object>[arg_identity, arg_attributes]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _FlutterConversationClientApiCodec extends StandardMessageCodec {
  const _FlutterConversationClientApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AttributesData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is AttributesData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is AttributesData) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is AttributesData) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is ConversationData) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is ConversationData) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is ConversationData) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is ConversationData) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else if (value is ConversationData) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    } else if (value is ConversationData) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    } else if (value is ConversationUpdatedData) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else if (value is ErrorInfoData) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else if (value is ErrorInfoData) {
      buffer.putUint8(140);
      writeValue(buffer, value.encode());
    } else if (value is ErrorInfoData) {
      buffer.putUint8(141);
      writeValue(buffer, value.encode());
    } else if (value is ErrorInfoData) {
      buffer.putUint8(142);
      writeValue(buffer, value.encode());
    } else if (value is MessageData) {
      buffer.putUint8(143);
      writeValue(buffer, value.encode());
    } else if (value is MessageData) {
      buffer.putUint8(144);
      writeValue(buffer, value.encode());
    } else if (value is MessageData) {
      buffer.putUint8(145);
      writeValue(buffer, value.encode());
    } else if (value is MessageMediaData) {
      buffer.putUint8(146);
      writeValue(buffer, value.encode());
    } else if (value is ParticipantData) {
      buffer.putUint8(147);
      writeValue(buffer, value.encode());
    } else if (value is ParticipantData) {
      buffer.putUint8(148);
      writeValue(buffer, value.encode());
    } else if (value is ParticipantData) {
      buffer.putUint8(149);
      writeValue(buffer, value.encode());
    } else if (value is ParticipantData) {
      buffer.putUint8(150);
      writeValue(buffer, value.encode());
    } else if (value is ParticipantData) {
      buffer.putUint8(151);
      writeValue(buffer, value.encode());
    } else if (value is UserData) {
      buffer.putUint8(152);
      writeValue(buffer, value.encode());
    } else if (value is UserData) {
      buffer.putUint8(153);
      writeValue(buffer, value.encode());
    } else if (value is UserData) {
      buffer.putUint8(154);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return AttributesData.decode(readValue(buffer)!);

      case 129:
        return AttributesData.decode(readValue(buffer)!);

      case 130:
        return AttributesData.decode(readValue(buffer)!);

      case 131:
        return AttributesData.decode(readValue(buffer)!);

      case 132:
        return ConversationData.decode(readValue(buffer)!);

      case 133:
        return ConversationData.decode(readValue(buffer)!);

      case 134:
        return ConversationData.decode(readValue(buffer)!);

      case 135:
        return ConversationData.decode(readValue(buffer)!);

      case 136:
        return ConversationData.decode(readValue(buffer)!);

      case 137:
        return ConversationData.decode(readValue(buffer)!);

      case 138:
        return ConversationUpdatedData.decode(readValue(buffer)!);

      case 139:
        return ErrorInfoData.decode(readValue(buffer)!);

      case 140:
        return ErrorInfoData.decode(readValue(buffer)!);

      case 141:
        return ErrorInfoData.decode(readValue(buffer)!);

      case 142:
        return ErrorInfoData.decode(readValue(buffer)!);

      case 143:
        return MessageData.decode(readValue(buffer)!);

      case 144:
        return MessageData.decode(readValue(buffer)!);

      case 145:
        return MessageData.decode(readValue(buffer)!);

      case 146:
        return MessageMediaData.decode(readValue(buffer)!);

      case 147:
        return ParticipantData.decode(readValue(buffer)!);

      case 148:
        return ParticipantData.decode(readValue(buffer)!);

      case 149:
        return ParticipantData.decode(readValue(buffer)!);

      case 150:
        return ParticipantData.decode(readValue(buffer)!);

      case 151:
        return ParticipantData.decode(readValue(buffer)!);

      case 152:
        return UserData.decode(readValue(buffer)!);

      case 153:
        return UserData.decode(readValue(buffer)!);

      case 154:
        return UserData.decode(readValue(buffer)!);

      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class FlutterConversationClientApi {
  static const MessageCodec<Object?> codec =
      _FlutterConversationClientApiCodec();

  void error(ErrorInfoData errorInfoData);
  void conversationAdded(ConversationData conversationData);
  void conversationUpdated(ConversationUpdatedData event);
  void conversationDeleted(ConversationData conversationData);
  void clientSynchronization(String synchronizationStatus);
  void conversationSynchronizationChange(ConversationData conversationData);
  void connectionStateChange(String connectionState);
  void tokenAboutToExpire();
  void tokenExpired();
  void userSubscribed(UserData userData);
  void userUnsubscribed(UserData userData);
  void userUpdated(UserData userData, String reason);
  void addedToConversationNotification(String conversationSid);
  void newMessageNotification(String conversationSid, int messageIndex);
  void notificationSubscribed();
  void notificationFailed(ErrorInfoData errorInfoData);
  void removedFromConversationNotification(String conversationSid);
  void registered();
  void registrationFailed(ErrorInfoData errorInfoData);
  void deregistered();
  void deregistrationFailed(ErrorInfoData errorInfoData);
  void messageAdded(String conversationSid, MessageData messageData);
  void messageUpdated(
      String conversationSid, MessageData messageData, String reason);
  void messageDeleted(String conversationSid, MessageData messageData);
  void participantAdded(
      String conversationSid, ParticipantData participantData);
  void participantUpdated(
      String conversationSid, ParticipantData participantData, String reason);
  void participantDeleted(
      String conversationSid, ParticipantData participantData);
  void typingStarted(String conversationSid, ConversationData conversationData,
      ParticipantData participantData);
  void typingEnded(String conversationSid, ConversationData conversationData,
      ParticipantData participantData);
  void synchronizationChanged(
      String conversationSid, ConversationData conversationData);
  static void setup(FlutterConversationClientApi? api) {
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.error', codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.error was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ErrorInfoData? arg_errorInfoData = args[0] as ErrorInfoData?;
          assert(arg_errorInfoData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.error was null, expected non-null ErrorInfoData.');
          api.error(arg_errorInfoData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.conversationAdded',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationAdded was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ConversationData? arg_conversationData =
              args[0] as ConversationData?;
          assert(arg_conversationData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationAdded was null, expected non-null ConversationData.');
          api.conversationAdded(arg_conversationData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.conversationUpdated',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ConversationUpdatedData? arg_event =
              args[0] as ConversationUpdatedData?;
          assert(arg_event != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationUpdated was null, expected non-null ConversationUpdatedData.');
          api.conversationUpdated(arg_event!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.conversationDeleted',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationDeleted was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ConversationData? arg_conversationData =
              args[0] as ConversationData?;
          assert(arg_conversationData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationDeleted was null, expected non-null ConversationData.');
          api.conversationDeleted(arg_conversationData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.clientSynchronization',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.clientSynchronization was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_synchronizationStatus = args[0] as String?;
          assert(arg_synchronizationStatus != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.clientSynchronization was null, expected non-null String.');
          api.clientSynchronization(arg_synchronizationStatus!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.conversationSynchronizationChange',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationSynchronizationChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ConversationData? arg_conversationData =
              args[0] as ConversationData?;
          assert(arg_conversationData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.conversationSynchronizationChange was null, expected non-null ConversationData.');
          api.conversationSynchronizationChange(arg_conversationData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.connectionStateChange',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.connectionStateChange was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_connectionState = args[0] as String?;
          assert(arg_connectionState != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.connectionStateChange was null, expected non-null String.');
          api.connectionStateChange(arg_connectionState!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.tokenAboutToExpire',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.tokenAboutToExpire();
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.tokenExpired',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.tokenExpired();
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.userSubscribed',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userSubscribed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final UserData? arg_userData = args[0] as UserData?;
          assert(arg_userData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userSubscribed was null, expected non-null UserData.');
          api.userSubscribed(arg_userData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.userUnsubscribed',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userUnsubscribed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final UserData? arg_userData = args[0] as UserData?;
          assert(arg_userData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userUnsubscribed was null, expected non-null UserData.');
          api.userUnsubscribed(arg_userData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.userUpdated', codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final UserData? arg_userData = args[0] as UserData?;
          assert(arg_userData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userUpdated was null, expected non-null UserData.');
          final String? arg_reason = args[1] as String?;
          assert(arg_reason != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.userUpdated was null, expected non-null String.');
          api.userUpdated(arg_userData!, arg_reason!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.addedToConversationNotification',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.addedToConversationNotification was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.addedToConversationNotification was null, expected non-null String.');
          api.addedToConversationNotification(arg_conversationSid!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.newMessageNotification',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.newMessageNotification was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.newMessageNotification was null, expected non-null String.');
          final int? arg_messageIndex = args[1] as int?;
          assert(arg_messageIndex != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.newMessageNotification was null, expected non-null int.');
          api.newMessageNotification(arg_conversationSid!, arg_messageIndex!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.notificationSubscribed',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.notificationSubscribed();
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.notificationFailed',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.notificationFailed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ErrorInfoData? arg_errorInfoData = args[0] as ErrorInfoData?;
          assert(arg_errorInfoData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.notificationFailed was null, expected non-null ErrorInfoData.');
          api.notificationFailed(arg_errorInfoData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.removedFromConversationNotification',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.removedFromConversationNotification was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.removedFromConversationNotification was null, expected non-null String.');
          api.removedFromConversationNotification(arg_conversationSid!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.registered', codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.registered();
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.registrationFailed',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.registrationFailed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ErrorInfoData? arg_errorInfoData = args[0] as ErrorInfoData?;
          assert(arg_errorInfoData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.registrationFailed was null, expected non-null ErrorInfoData.');
          api.registrationFailed(arg_errorInfoData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.deregistered',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.deregistered();
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.deregistrationFailed',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.deregistrationFailed was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ErrorInfoData? arg_errorInfoData = args[0] as ErrorInfoData?;
          assert(arg_errorInfoData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.deregistrationFailed was null, expected non-null ErrorInfoData.');
          api.deregistrationFailed(arg_errorInfoData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.messageAdded',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageAdded was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageAdded was null, expected non-null String.');
          final MessageData? arg_messageData = args[1] as MessageData?;
          assert(arg_messageData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageAdded was null, expected non-null MessageData.');
          api.messageAdded(arg_conversationSid!, arg_messageData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.messageUpdated',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageUpdated was null, expected non-null String.');
          final MessageData? arg_messageData = args[1] as MessageData?;
          assert(arg_messageData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageUpdated was null, expected non-null MessageData.');
          final String? arg_reason = args[2] as String?;
          assert(arg_reason != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageUpdated was null, expected non-null String.');
          api.messageUpdated(
              arg_conversationSid!, arg_messageData!, arg_reason!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.messageDeleted',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageDeleted was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageDeleted was null, expected non-null String.');
          final MessageData? arg_messageData = args[1] as MessageData?;
          assert(arg_messageData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.messageDeleted was null, expected non-null MessageData.');
          api.messageDeleted(arg_conversationSid!, arg_messageData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.participantAdded',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantAdded was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantAdded was null, expected non-null String.');
          final ParticipantData? arg_participantData =
              args[1] as ParticipantData?;
          assert(arg_participantData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantAdded was null, expected non-null ParticipantData.');
          api.participantAdded(arg_conversationSid!, arg_participantData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.participantUpdated',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantUpdated was null, expected non-null String.');
          final ParticipantData? arg_participantData =
              args[1] as ParticipantData?;
          assert(arg_participantData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantUpdated was null, expected non-null ParticipantData.');
          final String? arg_reason = args[2] as String?;
          assert(arg_reason != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantUpdated was null, expected non-null String.');
          api.participantUpdated(
              arg_conversationSid!, arg_participantData!, arg_reason!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.participantDeleted',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantDeleted was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantDeleted was null, expected non-null String.');
          final ParticipantData? arg_participantData =
              args[1] as ParticipantData?;
          assert(arg_participantData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.participantDeleted was null, expected non-null ParticipantData.');
          api.participantDeleted(arg_conversationSid!, arg_participantData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.typingStarted',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingStarted was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingStarted was null, expected non-null String.');
          final ConversationData? arg_conversationData =
              args[1] as ConversationData?;
          assert(arg_conversationData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingStarted was null, expected non-null ConversationData.');
          final ParticipantData? arg_participantData =
              args[2] as ParticipantData?;
          assert(arg_participantData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingStarted was null, expected non-null ParticipantData.');
          api.typingStarted(arg_conversationSid!, arg_conversationData!,
              arg_participantData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.typingEnded', codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingEnded was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingEnded was null, expected non-null String.');
          final ConversationData? arg_conversationData =
              args[1] as ConversationData?;
          assert(arg_conversationData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingEnded was null, expected non-null ConversationData.');
          final ParticipantData? arg_participantData =
              args[2] as ParticipantData?;
          assert(arg_participantData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.typingEnded was null, expected non-null ParticipantData.');
          api.typingEnded(arg_conversationSid!, arg_conversationData!,
              arg_participantData!);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterConversationClientApi.synchronizationChanged',
          codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.synchronizationChanged was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_conversationSid = args[0] as String?;
          assert(arg_conversationSid != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.synchronizationChanged was null, expected non-null String.');
          final ConversationData? arg_conversationData =
              args[1] as ConversationData?;
          assert(arg_conversationData != null,
              'Argument for dev.flutter.pigeon.FlutterConversationClientApi.synchronizationChanged was null, expected non-null ConversationData.');
          api.synchronizationChanged(
              arg_conversationSid!, arg_conversationData!);
          return;
        });
      }
    }
  }
}

class _FlutterLoggingApiCodec extends StandardMessageCodec {
  const _FlutterLoggingApiCodec();
}

abstract class FlutterLoggingApi {
  static const MessageCodec<Object?> codec = _FlutterLoggingApiCodec();

  void logFromHost(String msg);
  static void setup(FlutterLoggingApi? api) {
    {
      const BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FlutterLoggingApi.logFromHost', codec);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.FlutterLoggingApi.logFromHost was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_msg = args[0] as String?;
          assert(arg_msg != null,
              'Argument for dev.flutter.pigeon.FlutterLoggingApi.logFromHost was null, expected non-null String.');
          api.logFromHost(arg_msg!);
          return;
        });
      }
    }
  }
}
